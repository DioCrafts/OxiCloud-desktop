// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../domain/entities/auth.dart';
import '../domain/entities/config.dart';
import '../domain/entities/sync_item.dart';
import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `get_engine`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `SyncEngine`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

/// Initialize the sync engine with configuration.
/// Must be called before any other operation.
Future<void> initialize({required SyncConfig config}) =>
    RustLib.instance.api.crateApiOxicloudInitialize(config: config);

/// Shutdown the sync engine gracefully
Future<void> shutdown() => RustLib.instance.api.crateApiOxicloudShutdown();

/// Login to OxiCloud server
Future<AuthResult> login(
        {required String serverUrl, required String username, required String password}) =>
    RustLib.instance.api
        .crateApiOxicloudLogin(serverUrl: serverUrl, username: username, password: password);

/// Logout and clear credentials
Future<void> logout() => RustLib.instance.api.crateApiOxicloudLogout();

/// Check if user is logged in
Future<bool> isLoggedIn() => RustLib.instance.api.crateApiOxicloudIsLoggedIn();

/// Get current server info
Future<ServerInfo?> getServerInfo() => RustLib.instance.api.crateApiOxicloudGetServerInfo();

/// Start automatic synchronization
Future<void> startSync() => RustLib.instance.api.crateApiOxicloudStartSync();

/// Stop automatic synchronization
Future<void> stopSync() => RustLib.instance.api.crateApiOxicloudStopSync();

/// Trigger immediate sync
Future<SyncResult> syncNow() => RustLib.instance.api.crateApiOxicloudSyncNow();

/// Get current sync status
Future<SyncStatusInfo> getSyncStatus() => RustLib.instance.api.crateApiOxicloudGetSyncStatus();

/// Get list of items pending sync
Future<List<SyncItem>> getPendingItems() => RustLib.instance.api.crateApiOxicloudGetPendingItems();

/// Get sync history
Future<List<SyncHistoryEntry>> getSyncHistory({required int limit}) =>
    RustLib.instance.api.crateApiOxicloudGetSyncHistory(limit: limit);

/// Get list of remote folders for selective sync
Future<List<RemoteFolder>> getRemoteFolders() =>
    RustLib.instance.api.crateApiOxicloudGetRemoteFolders();

/// Set folders to sync (selective sync)
Future<void> setSyncFolders({required List<String> folderIds}) =>
    RustLib.instance.api.crateApiOxicloudSetSyncFolders(folderIds: folderIds);

/// Get currently selected sync folders
Future<List<String>> getSyncFolders() => RustLib.instance.api.crateApiOxicloudGetSyncFolders();

/// Get list of conflicts
Future<List<SyncConflict>> getConflicts() => RustLib.instance.api.crateApiOxicloudGetConflicts();

/// Resolve a conflict
Future<void> resolveConflict(
        {required String conflictId, required ConflictResolution resolution}) =>
    RustLib.instance.api
        .crateApiOxicloudResolveConflict(conflictId: conflictId, resolution: resolution);

/// Update sync configuration
Future<void> updateConfig({required SyncConfig config}) =>
    RustLib.instance.api.crateApiOxicloudUpdateConfig(config: config);

/// Get current sync configuration
Future<SyncConfig> getConfig() => RustLib.instance.api.crateApiOxicloudGetConfig();

/// Authentication result
class AuthResult {
  final bool success;
  final String userId;
  final String username;
  final ServerInfo serverInfo;
  final String accessToken;

  const AuthResult({
    required this.success,
    required this.userId,
    required this.username,
    required this.serverInfo,
    required this.accessToken,
  });

  @override
  int get hashCode =>
      success.hashCode ^
      userId.hashCode ^
      username.hashCode ^
      serverInfo.hashCode ^
      accessToken.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AuthResult &&
          runtimeType == other.runtimeType &&
          success == other.success &&
          userId == other.userId &&
          username == other.username &&
          serverInfo == other.serverInfo &&
          accessToken == other.accessToken;
}

/// Remote folder info for selective sync
class RemoteFolder {
  final String id;
  final String name;
  final String path;
  final BigInt sizeBytes;
  final int itemCount;
  final bool isSelected;

  const RemoteFolder({
    required this.id,
    required this.name,
    required this.path,
    required this.sizeBytes,
    required this.itemCount,
    required this.isSelected,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      name.hashCode ^
      path.hashCode ^
      sizeBytes.hashCode ^
      itemCount.hashCode ^
      isSelected.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RemoteFolder &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          path == other.path &&
          sizeBytes == other.sizeBytes &&
          itemCount == other.itemCount &&
          isSelected == other.isSelected;
}

/// Sync conflict info (API view)
class SyncConflict {
  final String id;
  final String itemPath;
  final PlatformInt64 localModified;
  final PlatformInt64 remoteModified;
  final BigInt localSize;
  final BigInt remoteSize;
  final ConflictType conflictType;

  const SyncConflict({
    required this.id,
    required this.itemPath,
    required this.localModified,
    required this.remoteModified,
    required this.localSize,
    required this.remoteSize,
    required this.conflictType,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      itemPath.hashCode ^
      localModified.hashCode ^
      remoteModified.hashCode ^
      localSize.hashCode ^
      remoteSize.hashCode ^
      conflictType.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SyncConflict &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          itemPath == other.itemPath &&
          localModified == other.localModified &&
          remoteModified == other.remoteModified &&
          localSize == other.localSize &&
          remoteSize == other.remoteSize &&
          conflictType == other.conflictType;
}

/// Sync history entry
class SyncHistoryEntry {
  final String id;
  final PlatformInt64 timestamp;
  final String operation;
  final String itemPath;
  final String direction;
  final String status;
  final String? errorMessage;

  const SyncHistoryEntry({
    required this.id,
    required this.timestamp,
    required this.operation,
    required this.itemPath,
    required this.direction,
    required this.status,
    this.errorMessage,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      timestamp.hashCode ^
      operation.hashCode ^
      itemPath.hashCode ^
      direction.hashCode ^
      status.hashCode ^
      errorMessage.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SyncHistoryEntry &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          timestamp == other.timestamp &&
          operation == other.operation &&
          itemPath == other.itemPath &&
          direction == other.direction &&
          status == other.status &&
          errorMessage == other.errorMessage;
}

/// Sync operation result
class SyncResult {
  final bool success;
  final int itemsUploaded;
  final int itemsDownloaded;
  final int itemsDeleted;
  final int conflicts;
  final List<String> errors;
  final BigInt durationMs;

  const SyncResult({
    required this.success,
    required this.itemsUploaded,
    required this.itemsDownloaded,
    required this.itemsDeleted,
    required this.conflicts,
    required this.errors,
    required this.durationMs,
  });

  @override
  int get hashCode =>
      success.hashCode ^
      itemsUploaded.hashCode ^
      itemsDownloaded.hashCode ^
      itemsDeleted.hashCode ^
      conflicts.hashCode ^
      errors.hashCode ^
      durationMs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SyncResult &&
          runtimeType == other.runtimeType &&
          success == other.success &&
          itemsUploaded == other.itemsUploaded &&
          itemsDownloaded == other.itemsDownloaded &&
          itemsDeleted == other.itemsDeleted &&
          conflicts == other.conflicts &&
          errors == other.errors &&
          durationMs == other.durationMs;
}

/// Current sync status info
class SyncStatusInfo {
  final bool isSyncing;
  final String? currentOperation;
  final double progressPercent;
  final int itemsSynced;
  final int itemsTotal;
  final PlatformInt64? lastSyncTime;
  final PlatformInt64? nextSyncTime;

  const SyncStatusInfo({
    required this.isSyncing,
    this.currentOperation,
    required this.progressPercent,
    required this.itemsSynced,
    required this.itemsTotal,
    this.lastSyncTime,
    this.nextSyncTime,
  });

  @override
  int get hashCode =>
      isSyncing.hashCode ^
      currentOperation.hashCode ^
      progressPercent.hashCode ^
      itemsSynced.hashCode ^
      itemsTotal.hashCode ^
      lastSyncTime.hashCode ^
      nextSyncTime.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SyncStatusInfo &&
          runtimeType == other.runtimeType &&
          isSyncing == other.isSyncing &&
          currentOperation == other.currentOperation &&
          progressPercent == other.progressPercent &&
          itemsSynced == other.itemsSynced &&
          itemsTotal == other.itemsTotal &&
          lastSyncTime == other.lastSyncTime &&
          nextSyncTime == other.nextSyncTime;
}
